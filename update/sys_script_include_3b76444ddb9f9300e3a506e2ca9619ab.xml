<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>false</active>
        <api_name>x_4s_tricode.DeleteRecordAjax</api_name>
        <client_callable>true</client_callable>
        <description>DeleteRecordAjax for Tricode Application Scope.</description>
        <name>DeleteRecordAjax</name>
        <script><![CDATA[var DeleteRecordAjax = Class.create();
DeleteRecordAjax.prototype = Object.extendsObject(AbstractAjaxProcessor, {
   
   getCascadeDeleteTables: function() {
      var confNeeded = gs.getProperty('glide.ui.confirm_cascade_delete');
      if(confNeeded == null || confNeeded != "true") {
         return '';
      }
      var objSysId = this.getParameter('sysparm_obj_id');
      var tblName = this.getParameter('sysparm_table_name');
      var stackName = this.getParameter('sysparm_nameofstack');
	  var gotoUrl = this.getParameter('sysparm_goto_url');
      
      var dMap = GlideCascadeFromDelete.getCascadeTables(tblName, objSysId, stackName);
      var retUrl = dMap.remove("return_url");

      // Use the more explicit sysparm_goto_url if it exists
      if (gotoUrl && gotoUrl != "")
          retUrl = gotoUrl;
	   
      var dList = '';
      if(retUrl != null) dList += retUrl + ';';
         else dList += 'null;';
         
      if( dMap.isEmpty()) {
         return dList;
      }
      
      // translate returned Java Map to a string format that client page can understand
      var objName = dMap.remove("name");
      dList += objName + ';';
      var itr = dMap.keySet().iterator();
      while(itr.hasNext()) {
         var dTbl = itr.next();
         var count = dMap.get(dTbl).intValue();
         dList = dList + count + ':' + dTbl + ',';
      }
      return dList;
   },
   
   isDomainUsed: function() {
   	var domainSysID = this.getParameter('sysparm_domain_id');
   	return GlideDomainSupport.isDomainUsed(domainSysID);
   },
	
   areDomainsUsed: function() {
		var selDomains = this.getParameter('sysparm_domain_ids');
	    var selDomainsList = selDomains.split(",");
		for(i = 0; i<selDomainsList.length; i++){
			if(GlideDomainSupport.isDomainUsed(selDomainsList[i]))
				return true;
		}
		return false;
	},
   
   proceedWithDeleteFromForm: function() {
      var objSysId = this.getParameter('sysparm_obj_id');
      var tblName = this.getParameter('sysparm_table_name');
	  var disableWf = this.getParameter('sysparm_disable_wf');
	   
      var gRecord = new GlideRecord(tblName);
	  if(JSUtil.notNil(disableWf) && disableWf == 'true') {
		 gRecord.setWorkflow(false);
	  }
	  if(gRecord.get(objSysId)) {
		  if (gRecord.canDelete())
	         gRecord.deleteRecord();
      }
      return true;
   },
   
   proceedWithDeleteFromList: function() {
      var objSysIds = this.getParameter('sysparm_obj_list');
      var tblName = this.getParameter('sysparm_table_name');
	   
      var objList = objSysIds.split(',');
      var gr = new GlideRecord(tblName);
      gr.initialize();
      if(new GlideTableDescriptor(tblName).isValidField('sys_id'))
        this.deleteMultiple(gr,objList);
      else
        this.deleteSingle(gr,objList);
    
      return true;
    },
  
    deleteMultiple: function(gr,objList) {
      // PRB570448, remove records that cannot be deleted because of ACL restrictions first
      // then call deleteMultiple(), since it uses DBQuery and bypasses ACL checks.
      var tblName = gr.getTableName();
      var sysIdsToDel = '';
      for(var i=0; i<objList.length; i++) {
      
        if(objList[i] == null || objList[i] == '') {
          continue;
        }
      
        gr.get('sys_id', objList[i]);
        if(gr.canDelete()) {
          if(i > 0) sysIdsToDel += ',';
            sysIdsToDel += objList[i];
        }
      }
      if(sysIdsToDel != '') {
        var gRecord = new GlideRecord(tblName);
        gRecord.addQuery('sys_id','IN', sysIdsToDel);
        if (GlideDomainSupport.getCurrentDomainValueOrGlobal() == 'global')
          gRecord.queryNoDomain();
        else
          gRecord.query();
        gRecord.deleteMultiple();
      }
    },
  
    deleteSingle: function(gr,objList) {
      for(var i=0; i<objList.length; i++) {
        if(objList[i] == null || objList[i] == '') {
          continue;
        }
        gr.get(objList[i]);
        if (gr.canDelete())
          gr.deleteRecord();
      }
   },
  
   toString: function() { return 'DeleteRecordAjax'; }
});
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>rthomas@tricorp-itsolutions.com</sys_created_by>
        <sys_created_on>2018-07-12 14:52:51</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>3b76444ddb9f9300e3a506e2ca9619ab</sys_id>
        <sys_mod_count>4</sys_mod_count>
        <sys_name>DeleteRecordAjax</sys_name>
        <sys_package display_value="TRICODE" source="x_4s_tricode">8912fb2adb789380e3a506e2ca961972</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="TRICODE">8912fb2adb789380e3a506e2ca961972</sys_scope>
        <sys_update_name>sys_script_include_3b76444ddb9f9300e3a506e2ca9619ab</sys_update_name>
        <sys_updated_by>john.duchock@4thsource.com</sys_updated_by>
        <sys_updated_on>2018-07-25 11:56:11</sys_updated_on>
    </sys_script_include>
</record_update>
